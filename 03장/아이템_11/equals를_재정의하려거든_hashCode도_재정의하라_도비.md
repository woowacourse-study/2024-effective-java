> KEYWORD: hashCode, equals, 자바, 해시 테이블, 일관성

## 들어가기에 앞서 Hash란 무엇일까?


해시 테이블은 효율적인 데이터 검색을 위해 널리 사용되는 데이터 구조 중 하나로, 키를 값에 매핑하여 데이터의 빠른 검색, 삽입, 삭제를 지원한다.



### 해시 테이블의 작동 원리

#### 1. 해싱 함수

- **정의**: 해시 테이블은 해싱 함수를 사용하여 키를 해시 코드로 변환한다. 해시 코드는 일반적으로 키를 배열의 인덱스로 변환하는 데 사용된다.
- **목표**: 좋은 해싱 함수는 충돌을 최소화하고, 해시 테이블의 공간을 균일하게 사용하도록 해야 한다.

#### 2. 충돌 해결 방법

해시 테이블에서는 두 개 이상의 키가 같은 해시 값을 가질 때 충돌이 발생한다. 충돌을 해결하는 두 가지 일반적인 방법은 다음과 같다.

##### a. 체이닝 (Chaining)

- **원리**: 각 인덱스에 연결 리스트를 사용하여 같은 해시 값을 가진 키들을 저장한다.
- **장점**: 구현이 간단하며, 해시 테이블의 로드 팩터가 클 때도 비교적 성능이 좋다.

##### b. 오픈 어드레싱 (Open Addressing)

- **원리**: 충돌이 발생하면, 다른 해시 버킷을 찾아 데이터를 저장한다. 선형 조사(linear probing), 이차 조사(quadratic probing), 이중 해싱(double hashing) 등의 방법이 있다.
- **장점**: 메모리를 더 효율적으로 사용할 수 있다.

#### 3. 리사이징 (Resizing)

- **필요성**: 로드 팩터(load factor, 테이블에 저장된 항목 수와 위치의 수 비율)가 높아지면, 충돌의 빈도가 증가하고 성능이 저하될 수 있다.
- **동작**: 해시 테이블의 크기를 조정하고 모든 항목을 새로운 테이블에 재해싱하여 성능을 유지한다.


## 그래서 HashCode는 왜 Override 해야 하는 걸까?

`hashCode` 메서드의 올바른 구현은 Java의 컬렉션 프레임워크, 특히 `HashMap`과 `HashSet`과 같은 해시 기반 컬렉션을 효율적으로 사용하기 위해 매우 중요하다. `equals` 메서드를 재정의한 클래스에서 `hashCode`도 올바르게 재정의하지 않으면, 해시 기반 컬렉션의 성능이 저하되거나 더 심각한 문제가 발생할 수 있다. 이를 위해 Java의 `Object` 클래스에서 제공하는 `hashCode` 일반 규약을 준수해야 한다.

### hashCode의 일반 규약

Java의 `Object` 클래스 명세에 따르면 `hashCode` 메서드는 다음과 같은 규약을 지켜야 한다.

#### 1. 일관성

- **정의**: 객체의 `equals` 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 해당 객체의 `hashCode` 메서드는 몇 번을 호출해도 항상 같은 값을 반환해야 한다.
- **예외**: 애플리케이션을 재실행할 때는 값이 달라질 수 있다.

#### 2. 동등 객체의 동일 해시코드

- **정의**: `equals(object)`가 두 객체를 같다고 판단했다면, 이 두 객체의 `hashCode`는 반드시 같은 값을 반환해야 한다.
- **문제**: `Object`의 기본 `hashCode` 메서드는 물리적으로 다른 두 객체에 대해 서로 다른 값을 반환할 수 있어, 이 규약을 위반할 수 있다.

#### 3. 동등하지 않은 객체의 해시코드

- **정의**: `equals(object)`가 두 객체를 다르다고 판단했다면, 두 객체의 `hashCode`가 서로 다른 값을 반환할 필요는 없으나, 다른 객체에 대해서는 가능한 한 다른 값을 반환하는 것이 해시 테이블의 성능을 개선한다.

### hashCode 재정의 예시

`Person` 클래스에 대한 `hashCode` 메서드의 올바른 구현 예를 살펴보자.


```java
public class Person {
    private String name;
    private int age;

...

    @Override
    public int hashCode() {
        int result = 17; // 초기 값
        result = 31 * result + Short.hashCode(name) ; // int 필드의 해시 코드 계산
        result = 31 * result + Short.hashCode(age); // 문자열 필드의 해시 코드
        return result;
    }
}


```
**설명**:

- **일관성 보장**: `name`과 `age`가 변경되지 않는 한, `hashCode` 호출 결과는 항상 같다.
- **동등 객체 동일 해시코드**: 동등한 `Person` 객체는 동일한 `name`과 `age` 값을 가지므로 동일한 해시코드 값을 반환한다.
- **효율적인 해시 분포**: 다른 `name`과 `age`를 가진 객체는 가능한 다른 해시코드 값을 반환하도록 구현함으로써 해시 테이블의 성능을 최적화한다.


### 잠깐만요, 31 곱하는건 왜 하는거죠?

```java
result = 31 * result + Short.hashCode(name) ;
result = 31 * result + Short.hashCode(age);
```


 
(i << 5) - i = i * 31
(i << 5) - i


잎서 작성한 hashCode() 메서드를 살펴보면, 31이라는 뜬금 없는 숫자를 곱하여 hashCode를 만든다.

**왜 31이며, 이걸 왜 곱하는걸까?**

답부터 말해보자면, 31은 **홀수이면서 Prime Number**이기 때문이다.

글의 서두에 언급한 Hash를 이용한 자료구조는 Hash Function을 이용하여 Hash Tabale에 정보를 매핑하는데, 이때 Hash Code는 Table의 특정 위치를 가르키게 된다. 

이때 Hash Code를 Hash Function에서 `%(mod)` 나누기 연산을 하여 테이블에서의 실질적 위치를 구하게 되는데, 위의 코드는 이 과정의 역과정인것이다.

그렇기에 아무런 약수가 없는 Prime Number인 31은 Hash Code의 역변환을 진행했을 때, Hash Table 위에 매핑되는 데이터의 Hash Key의 중복이 상대적으로 최소화될 수 있다. (Hash Table에서 충돌이 발생하면 이 충돌을 해소하기 위한 방법들은 추가적인 자원을 소모하기 때문에 충돌을 최대한 피해야한다)
