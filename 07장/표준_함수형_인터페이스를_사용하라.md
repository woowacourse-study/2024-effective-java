> 작성자: 프람
> 작성일시: 2024.05.24

## 함수형 인터페이스
자바8부터 람다를 지원하면서 API를 작성하는 모범 사례가 크게 변하하였다.

예를 들자면, 중복 코드를 줄이고, OCP를 준수하기 위한 템플릿 메서드 패턴의 사용도 크게 줄일 수 있다.


LinkedHashMap의 예시를 살펴보자.
실제 Map에 원소를 추가할 때 특정 크기만큼만 유지하고 오래된 원소는 삭제하는 코드가 아래에 있다. 

코드는 템플릿 메서드로 구현 되어 있다.
먼조 코드를 살펴보고,  함수형 인터페이스로 개선해보자! 


😊**실험대상**😊
```java
  
public class LinkedHashMap<K,V> {
	public LinkedHashMap(int initialCapacity) {  
	    super(initialCapacity);  
	    accessOrder = false;  
	}
	
	// 생략 ...
	void afterNodeInsertion(boolean evict) { // possibly remove eldest  
    LinkedHashMap.Entry<K,V> first;  
	    if (evict && (first = head) != null && removeEldestEntry(first)) {  
	        K key = first.key;  
	        removeNode(hash(key), key, null, false, true);  
	    }  
	}
	// 생략 ... 
  
	protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {  
	    return false;  
	}
	// 생략 ... 
}
```

😅**템플릿 메서드 패턴 예시**😅
너무 나도 당연한 이야기 이지만, 상속을 통한 LinkedHashMap 캐싱 사례입니다.

```java
class TemplateMethodLinkedHashMap extends LinkedHashMap<String, Integer> {

	private static final int MAX_ENTRIES = 100;

	@Override
	protected boolean removeEldestEntry(Map.Entry eldest) {
		return size() > MAX_ENTRIES;
	}

}
```

👍**함수형 인터페이스 적용**👍

이렇게 된다면 어떤가요? 새로운 삭제 전략이 생긴다 하더라도 코드 생성없이 외부에서 함수형 인터페이스 맞는 람다식만을 제공하면 됩니다.

```java
@FunctionalInterface
public interface RemovalFunction<K, V> {
    boolean remove(Map<K, V> map, Map.Entry<K, V> eldest);
}


class FunctionalLinkedHashMap extends LinkedHashMap<String, Integer> {

    private final RemovalFunction<String, Integer> removalFunction;

    FunctionalLinkedHashMap(RemovalFunction<String, Integer> removalFunction) {
        this.removalFunction = removalFunction;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<String, Integer> eldest) {
        return removalFunction.remove(this, eldest);
    }
}
```

그런데 , 다들 여기서 의문이 들지 않나요? 굳이 BiPredicate이 있는데, 왜 RemovalFunction을 정의해야하나 하는 것이죠.. 맞습니다. 자바에서 지원하는 표준 함수형 인터페이스는 43개나 있기 때문에 왠만한 상황은 모두 커버가 가능합니다.

```java
class BiPredicateLinkedHashMap extends LinkedHashMap<String, Integer> {

	    private final BiPredicate<Map<String, Integer>, Map.Entry<String, Integer>> removalBiPredicate;

    BiPredicateLinkedHashMap(BiPredicate<Map<String, Integer>, Map.Entry<String, Integer>> removalBiPredicate) {
        this.removalBiPredicate = removalBiPredicate;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<String, Integer> eldest) {
        return removalBiPredicate.test(this, eldest);
    }
}
```

**😗클라이언트 코드😗**
```java
BipredicateLinkedHashMap map = new BipredicateLinkedHashMap((map, eldest) -> map.size > 100); 
```
## 자주 사용되는 표준 함수형 인터페이스

| 인터페이스              | 함수 시그니처             | 예                   |
| ------------------ | ------------------- | ------------------- |
| UnaryOperator\<T>  | T apply(T t)        | String::toLowerCase |
| BinaryOperator\<T> | T apply(T t1, T t2) | BigInteger::add     |
| Predicate\<T>      | boolean test(T t)   | Collection::isEmpty |
| Function\<T>       | R apply(T t)        | Array::asList       |
| Supplier\<T>       | T get()             | Instant::now        |
| Consumer\<T>       | void accept(T t)    | System.out::println |
## 기본 타입 인터페이스
int, long, double 3가지의 기본 타입 인터페이스를 지원해준다는 사실 알고 계셨나요??

> 예시 1: ToLongFunction // 한개의 인자 타입을 받아 long으로 반환 <br/>
> 예시 2: LongFunction\<int[]> // long을 인자로 받아 int[]를 반환 <br/>
> 예시 3: BooleanSupplier // boolean을 반환하는 supplier <br/>

이런식으로 타입을 명시적으로 표현해주는 표준 함수형 인터페이스까지 앞서 언급한것과 같이 
43개나 됩니다. 다 외울수 있어요?? 없습니다. 그래서 위의 예시와 범용적이고 일관적인 네이밍으로 이해하기 쉽게 만들었으니 필요할때마다 찾아 사용합시다!!

## 정리
함수형 인터페이스를 잘 사용하자!
